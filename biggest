#!/usr/bin/env bash

app_name='biggest'
app_version='0.3'

exclude=()

OPTIND=1
while getopts ':hvutblLd:n:x:' OPTION; do
	case "$OPTION" in
	h)
		cat <<EOF
${app_name} [options] [path...]

List biggest files and folders.

options:
  -h                show help and exi
  -v                show version and exit
  -u                size of disk usage rather than apparent size
  -b                display horizontal bar instead number
  -t                count and add total size
  -l                follow symbolic links from commandline arguments only
  -L                follow all symbolic links
  -d NUM            max depth of directories to traverse
  -n NUM            max number of output lines
  -x PATTERN        exclude files by wildcard pattern

Copyright Â© 2024 Tuncay D. <https://github.com/thingsiplay/${app_name}>
EOF
		exit 0
		;;
	v)
		echo "${app_name} v${app_version}"
		exit 0
		;;
	u)
		disk_usage=true
		;;
	t)
		total_size=true
		;;
	b)
		horizontal_bar=true
		;;
	l)
		follow_args_links=true
		;;
	L)
		follow_all_links=true
		;;
	d)
		if ! [[ ${OPTARG} =~ ^[0-9]+$ ]]; then
			echo "Only digits allowed for -d: '${OPTARG}'" >&2
			exit 1
		fi
		max_depth="${OPTARG}"
		;;
	n)
		if ! [[ ${OPTARG} =~ ^[0-9]+$ ]]; then
			echo "Only digits allowed for -l: '${OPTARG}'" >&2
			exit 1
		fi
		max_lines="${OPTARG}"
		;;
	x)
		exclude+=("${OPTARG}")
		;;
	?)
		echo "Error parsing options: '${OPTARG}'" >&2
		exit 1
		;;
	esac
done
shift "$((OPTIND - 1))"

files=("${@}")

if [ "${#files[@]}" -eq 0 ]; then
	mapfile -t files < <(find ./* -maxdepth 0)
fi

if [ -z "${max_depth}" ]; then
	max_depth=0
fi

du_cmd=(
	du
	--all
	--max-depth
	"${max_depth}"
	--one-file-system
)

if [ -z "${max_lines}" ]; then
	max_lines="${#files[@]}"
fi

if [ -n "${total_size}" ] || [ "${total_size}" == true ]; then
	du_cmd+=(--total)
	max_lines=$((max_lines + 1))
fi

if [ -z "${disk_usage}" ] || [ "${disk_usage}" == false ]; then
	du_cmd+=(--apparent-size)
fi

if [ -n "${follow_args_links}" ] && [ "${follow_args_links}" == true ]; then
	du_cmd+=(--dereference-args)
elif [ -n "${follow_all_links}" ] && [ "${follow_all_links}" == true ]; then
	du_cmd+=(--dereference)
fi

for x in "${exclude[@]}"; do
	du_cmd+=(--exclude "${x}")
done

sort_cmd=(
	sort
	--human-numeric-sort
	--ignore-leading-blanks
	--reverse
)

head_cmd=(
	head
	--lines
	"${max_lines}"
)

if [ -z "${horizontal_bar}" ] || [ "${horizontal_bar}" == false ]; then
	du_cmd+=(--human-readable)
	"${du_cmd[@]}" -- "${files[@]}" | "${sort_cmd[@]}" | "${head_cmd[@]}"
else
	output=$("${du_cmd[@]}" -- "${files[@]}" | "${sort_cmd[@]}" | "${head_cmd[@]}")

	# \u2592, \u2584, \u2596
	barcode="$(printf '\u2592')"
	sizes="$(printf '%s' "${output}" | awk -F '\t' '{print $1}')"
	paths="$(printf '%s' "${output}" | awk -F '\t' '{print $2}')"
	sizes_f="$(printf '%s\n' "${sizes}" | sed "s/[0-9]/${barcode}/g")"

	paste \
		<(printf '%s' "${sizes_f}") \
		<(printf '%s' "${paths}") \
		--delimiters '\t' | column -s $'\t' -t
fi
